---
title: "KausInf"
author: "Mattes Grundmann, Oya Bazer, Jakob Zschocke"
date: "2023-06-07"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

install.packages("tidyverse", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=tidyverse")
install.packages("lmtest", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=lmtest")
install.packages("sandwich", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=sandwich")
install.packages("MatchIt", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=MatchIt")
install.packages("twang", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=twang")
install.packages("nlme", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=nlme")
install.packages("ggplot2", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=ggplot2")
install.packages("tsModel", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=tsModel")
```

```{r}
library(tidyverse)
library(lmtest)
library(sandwich)
library(MatchIt) 
library(twang)
library(survey)
library(nlme)
library(ggplot2)
library(tsModel)
```

#Es wurden die benötigten Packages installiert und geladen #benötigter Datensatz wird anschließend geladen

```{r}
smk_data <- read_csv("https://raw.githubusercontent.com/gckc123/Causal_Analysis_Addiction_Examples/main/smoking_psyc_distress.csv")
```

```{r}
smk_data$remoteness <- as.factor(smk_data$remoteness)
```

#Matching Funktion wird ausgeführt, um die Gruppen vergleichbar zu machen.

```{r}
smk_matching <- matchit(smoker ~ sex + indigeneity + high_school + partnered + remoteness + language + risky_alcohol + age, data = smk_data, method = "optimal", distance = "glm")

#Um die Daten komprimiert auszugeben wird hier die summary Funktion für den gematchten Datensatz angewendet.
summary(smk_matching)
```

#Anschließend werden die Daten für mehr Übersichtlichkeit geplottet, man sieht, dass die Mean Difference jetzt deutlich geringer geworden ist.

```{r}
plot(summary(smk_matching), abs=FALSE)
```

#Nachdem die Gruppen vergleichbar gemacht wurden, wird jetzt mittels Regression etc. der Effect von Rauchen auf Psyche gemessen.

```{r}
matched_data <- match.data(smk_matching)
smk_model1 <- lm(psyc_distress ~ smoker, data = matched_data, weights = weights)
summary(smk_model1)
coeftest(smk_model1, vcov. = vcovCL, cluster = ~subclass)
coefci(smk_model1, vcov. = vcovCL, cluster = ~subclass, level = 0.95)
```

```{r}
smk_model2 <- lm(psyc_distress ~ smoker + sex + indigeneity + high_school + partnered + remoteness + language + risky_alcohol + age, data = matched_data, weights = weights)
summary(smk_model2)
coeftest(smk_model2, vcov. = vcovCL, cluster = ~subclass)
coefci(smk_model2, vcov. = vcovCL, cluster = ~subclass, level = 0.95)
```

Appendix 2
##Inverse Probability Treatment Weighting

Inverse Probability Weighting (IPW) is a statistical technique used in observational studies to estimate the causal effect of a treatment or intervention. Its primary objective is to address potential confounding variables and (like the matching method) achieve balance between the treatment and control groups. In IPW, propensity scores are calculated for each individual in the study population. These scores represent the probability of receiving the treatment, given a set of observed covariates, like in this case religion or education. 
Once the propensity scores are obtained, weights are assigned to each individual based on their propensity score. Individuals in the treatment group are assigned weights that are the inverse of their propensity score, while individuals in the control group are assigned weights derived from the inverse of one minus the propensity score. These weights help balance the groups by giving more weight to individuals who are less likely to receive the treatment, and vice versa.
The weighted data is then used to estimate the causal effect of the treatment using appropriate statistical methods such as regression models or stratification techniques.

#Balance the groups

```{r}
#Here starts the part for IPTW method. The same data is being used, with remoteness variable recoded as factor variable.

smk_iptw <- ps(smoker ~ sex + indigeneity + high_school + partnered + remoteness + language + risky_alcohol + age, interaction.depth = 3, data = as.data.frame(smk_data), n.tree = 5000, estimand = "ATE", verbose = FALSE)

bal.table(smk_iptw)
```

The ps()-function is being used to estimate the propensity scores. The variable smoker is the outcome variable, and the other variables listed are the predictors used to predict the likelihood of being a smoker (Receiving the Treatment).
The result is stored in the smk_iptw object, which can then be further used for estimating the causal effect of the treatment on smoking behavior.

The command "bal.table(smk_iptw)" calculates a balance table for the variables in relation to the created propensity score model "smk_iptw".
In this case, the focus is on the first and third table and on the column "std. eff. sz". In the first table, there are substantial differences in all variables in the original data between the two groups (> 0.1). Compared to that, in the third table, which represents the weighted data, the differences are close to 0. So a much better balance between the groups regarding the covariates is achieved. 

```{r}
plot(smk_iptw)

```
#Extract the weights

```{r}
#extract the weights
smk_data$weight <- get.weights(smk_iptw, stop.method = "es.mean")
```
With the previous step, the weights can now be extracted.
The get.weights()-function is used to calculate the weights for the observations based on the propensity score analysis. The relevant object was defined above as smk_iptw. This object contains the necessary information to compute the weights. 
By executing this code, the propensity score weights are calculated for each observation in the "smk_data" dataset and stored in the newly created "weight" variable. 

#Estimate the Treatment Effect

```{r}

#Estimate the Treatment Effect

design_iptw <- svydesign(ids = ~1, weights = ~weight, data = smk_data)
smk_model3 <- svyglm(psyc_distress ~ smoker, design = design_iptw)
summary(smk_model3)
```
After using IPTW, the Treatment Effect can now be estimated.
The function svyglm() estimates a generalized linear model (glm) for psychological distress (psyc_distress) based on the variable smoker.
The model is fitted using the previously created survey design design_iptw with inverse probability weighting. The results of the model are assigned to the variable smk_model3. 
The following summary ()-function provides the results from the smk_model3. It includes statistical information such as estimates, standard errors, p-values, and confidence intervals for the estimated model coefficients. 
By running these code snippets, estimates, summaries, and confidence intervals are computed for the relationship between smoking and psychological distress. The results can be used to analyze the impact of smoking on mental health and draw conclusions. By using Inverse Probability Weighting before, we got a much better estimate for the causal relationship between smoking and psychiological distress by migate the impact of the confounding variables and create balance between treatment and control group. 

In this case, the analysis estimates that smoking leads to an increase of 1.73 points in psychological distress compared to non-smokers. 

```{r}
confint(smk_model3)
```

```{r}
#doubly robust estimation
smk_model4 <- svyglm(psyc_distress ~ smoker + sex + indigeneity + high_school + partnered + remoteness + language + risky_alcohol + age, design = design_iptw)
summary(smk_model4)
confint(smk_model4)
```
In this part, the effect of the minimum alcohol pricing on alcohol consumption at the population level is estimated in Northern Territory, Australia, using interrupted time series analysis.

```{r}
#load the dataset
alc_mup_data <- read_csv("https://statsnotebook.io/blog/data_management/example_data/alcohol_data_NTWA.csv")

#state and intervention variables are being converted into factor.
alc_mup_data$state <- factor(alc_mup_data$state, exclude = c("", NA))
alc_mup_data$intervention <- factor(alc_mup_data$intervention, exclude = c("", NA))

#relevel() function is being used to set the reference level of the state variable to be “WA” (Western Australia).
alc_mup_data$state <- relevel(alc_mup_data$state, ref="WA")

#the descriptive statistics generated by states and by pre/post intervention.
alc_mup_data %>%
  group_by(state, intervention) %>%
  summarize(count = n(),
            M_alcohol = mean(alcohol, na.rm = TRUE),
            Mdn_alcohol = median(alcohol, na.rm = TRUE),
            SD_alcohol = sd(alcohol, na.rm = TRUE),
            IQR_alcohol = IQR(alcohol, na.rm = TRUE)
  ) %>% 
  print()
```

```{r}
#using the ggplot() function to visualize alcohol consumption level by state and by pre/post intervention.
ggplot(alc_mup_data) +
  geom_boxplot(aes(y=alcohol, x=state, fill = intervention))
```

The descriptive analysis suggests that alcohol minimum pricing likely reduced alcohol consumption in the population.

```{r}
#estimating the intervention effect of alcohol minimum pricing on population level alcohol consumption, using gls() function
res <- gls(alcohol ~ time*intervention*state,
           data = alc_mup_data,
           correlation = corARMA(p = 1, form =~ time | state), method = "ML")
summary(res)
```
While alcohol consumption in the Northern Territory was higher than in Western Australia before alcohol minimum pricing, there was no significant difference in the pre-intervention trend (as indicated by the time by state interaction). Immediately after implementing minimum alcohol price, there was a significant drop in alcohol consumption in the Northern Territory but not in Western Australia (as indicated by the intervention by state interaction).
```{r}
#generating the model-based prediction
alc_mup_data$predicted <- res$fitted

#generating the interaction for ggplots
groups = interaction(alc_mup_data$intervention,alc_mup_data$state)

#ploting the time series
plot <- ggplot() +
  geom_point(data = alc_mup_data, aes(y = alcohol, x = time, color = state)) +
  geom_line(data = alc_mup_data, aes(y = predicted, x = time, color = state, group = groups)) +
  geom_vline(xintercept = max((alc_mup_data %>% filter(intervention == "0"))$time), linetype = 
               "dashed") +
  theme_bw(base_family = "sans") +
  theme(legend.position = "bottom")
plot
```
#Our model has accounted for lag-1 autocorrelation. We can evaluate if this is sufficient using the partial auto-correlation function. The acf() can be used with the type parameter set to "partial". In this analysis, we will need to plot the auto-correlation function for Western Australia and Northern Territory separately.
```{r}
#extract the residuals
alc_mup_data$residuals <- residuals(res)

#plotting the partial ACF
pacf(alc_mup_data[alc_mup_data$state == "NT",]$residuals)
pacf(alc_mup_data[alc_mup_data$state == "WA",]$residuals)
```
Autocorrelation measures how a variable is related to its past values and is a way to assess if there is a pattern or dependency within a time series.
```{r}
#Both PACF plots suggest that we should adjust for up to the lag-4 auto-correlation. The analysis can be rerun by setting the p parameter to 4, as follow.

res2 <- gls(alcohol ~ time*intervention*state,
            data = alc_mup_data,
            correlation = corARMA(p = 4, form =~ time | state), method = "ML")
summary(res2)
```

```{r}
#adjust for seasonality



#The harmonic function is used to calculate the harmonic terms calculate based on sine and cosine function
#the first parameter of this function specifies the time variable
#the second specifies the number of sine and cosine pairs to include
#the third specifies the length of the period

alc_mup_data <- cbind(alc_mup_data, data.frame(harmonic(alc_mup_data$time, 1, 12)))
alc_mup_data <- alc_mup_data %>% 
  rename(harmonic1 = X1,
         harmonic2 = X2)
res <- gls(alcohol ~ time*intervention*state + harmonic1 + harmonic2,
           data = alc_mup_data,
           correlation = corARMA(p = 1, form =~ time | state), method = "ML")
summary(res)
```

```{r}
#calculate the predicted value
alc_mup_data$predicted <- res$fitted
groups = interaction(alc_mup_data$intervention,alc_mup_data$state)

#calculate the predicted linear trend for data visualisation
alc_mup_data.linear <- alc_mup_data
alc_mup_data.linear$harmonic1 <- 0
alc_mup_data.linear$harmonic2 <- 0
alc_mup_data.linear$predicted <- predict(res, alc_mup_data.linear)

#plot the time series
plot <- ggplot() +
  geom_point(data = alc_mup_data, aes(y = alcohol, x = time, color = state)) +
  geom_line(data = alc_mup_data, aes(y = predicted, x = time, color = state, group = groups), linetype = "dashed") +
  geom_line(data = alc_mup_data.linear, aes(y = predicted, x = time, color = state, group = groups)) +
  geom_vline(xintercept = max((alc_mup_data %>% filter(intervention == "0"))$time), linetype = "dashed") +
  theme_bw(base_family = "sans") +
  theme(legend.position = "bottom")
plot
```
