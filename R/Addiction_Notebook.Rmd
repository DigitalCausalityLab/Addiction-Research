---
title: "KausInf"
author: "Mattes Grundmann, Oya Bazer, Jakob Zschocke"
date: "2023-06-07"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

install.packages("tidyverse", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=tidyverse")
install.packages("lmtest", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=lmtest")
install.packages("sandwich", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=sandwich")
install.packages("MatchIt", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=MatchIt")
install.packages("twang", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=twang")
install.packages("nlme", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=nlme")
install.packages("ggplot2", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=ggplot2")
install.packages("tsModel", dependencies = TRUE, repos = "https://CRAN.R-project.org/package=tsModel")
```

```{r}
library(tidyverse)
library(lmtest)
library(sandwich)
library(MatchIt) 
library(twang)
library(survey)
library(nlme)
library(ggplot2)
library(tsModel)
```

#Es wurden die benötigten Packages installiert und geladen #benötigter Datensatz wird anschließend geladen

```{r}
smk_data <- read_csv("https://raw.githubusercontent.com/gckc123/Causal_Analysis_Addiction_Examples/main/smoking_psyc_distress.csv")
```

```{r}
smk_data$remoteness <- as.factor(smk_data$remoteness)
```

#Matching Funktion wird ausgeführt, um die Gruppen vergleichbar zu machen.

```{r}
smk_matching <- matchit(smoker ~ sex + indigeneity + high_school + partnered + remoteness + language + risky_alcohol + age, data = smk_data, method = "optimal", distance = "glm")

#Um die Daten komprimiert auszugeben wird hier die summary Funktion für den gematchten Datensatz angewendet.
summary(smk_matching)
```

#Anschließend werden die Daten für mehr Übersichtlichkeit geplottet, man sieht, dass die Mean Difference jetzt deutlich geringer geworden ist.

```{r}
plot(summary(smk_matching), abs=FALSE)
```

#Nachdem die Gruppen vergleichbar gemacht wurden, wird jetzt mittels Regression etc. der Effect von Rauchen auf Psyche gemessen.

```{r}
matched_data <- match.data(smk_matching)
smk_model1 <- lm(psyc_distress ~ smoker, data = matched_data, weights = weights)
summary(smk_model1)
coeftest(smk_model1, vcov. = vcovCL, cluster = ~subclass)
coefci(smk_model1, vcov. = vcovCL, cluster = ~subclass, level = 0.95)
```

```{r}
smk_model2 <- lm(psyc_distress ~ smoker + sex + indigeneity + high_school + partnered + remoteness + language + risky_alcohol + age, data = matched_data, weights = weights)
summary(smk_model2)
coeftest(smk_model2, vcov. = vcovCL, cluster = ~subclass)
coefci(smk_model2, vcov. = vcovCL, cluster = ~subclass, level = 0.95)
```

Appendix 2

```{r}
#Here starts the part for IPTW method. The same data is being used, with remoteness variable recoded as factor variable.

smk_iptw <- ps(smoker ~ sex + indigeneity + high_school + partnered + remoteness + language + risky_alcohol + age, interaction.depth = 3, data = as.data.frame(smk_data), n.tree = 5000, estimand = "ATE", verbose = FALSE)

plot(smk_iptw)
bal.table(smk_iptw)
```

```{r}
#extract the weights
smk_data$weight <- get.weights(smk_iptw, stop.method = "es.mean")

#Schätzung des Treatment Effekts
design_iptw <- svydesign(ids = ~1, weights = ~weight, data = smk_data)
smk_model3 <- svyglm(psyc_distress ~ smoker, design = design_iptw)
summary(smk_model3)
confint(smk_model3)
```

```{r}
#doubly robust estimation
smk_model4 <- svyglm(psyc_distress ~ smoker + sex + indigeneity + high_school + partnered + remoteness + language + risky_alcohol + age, design = design_iptw)
summary(smk_model4)
confint(smk_model4)
```
In this part, the effect of the minimum alcohol pricing on alcohol consumption at the population level is estimated in Northern Territory, Australia, using interrupted time series analysis.

```{r}
#load the dataset
alc_mup_data <- read_csv("https://statsnotebook.io/blog/data_management/example_data/alcohol_data_NTWA.csv")

#state and intervention variables are being converted into factor.
alc_mup_data$state <- factor(alc_mup_data$state, exclude = c("", NA))
alc_mup_data$intervention <- factor(alc_mup_data$intervention, exclude = c("", NA))

#relevel() function is being used to set the reference level of the state variable to be “WA” (Western Australia).
alc_mup_data$state <- relevel(alc_mup_data$state, ref="WA")

#the descriptive statistics generated by states and by pre/post intervention.
alc_mup_data %>%
  group_by(state, intervention) %>%
  summarize(count = n(),
            M_alcohol = mean(alcohol, na.rm = TRUE),
            Mdn_alcohol = median(alcohol, na.rm = TRUE),
            SD_alcohol = sd(alcohol, na.rm = TRUE),
            IQR_alcohol = IQR(alcohol, na.rm = TRUE)
  ) %>% 
  print()
```

```{r}
#using the ggplot() function to visualize alcohol consumption level by state and by pre/post intervention.
ggplot(alc_mup_data) +
  geom_boxplot(aes(y=alcohol, x=state, fill = intervention))
```

The descriptive analysis suggests that alcohol minimum pricing likely reduced alcohol consumption in the population.

```{r}
#estimating the intervention effect of alcohol minimum pricing on population level alcohol consumption, using gls() function
res <- gls(alcohol ~ time*intervention*state,
           data = alc_mup_data,
           correlation = corARMA(p = 1, form =~ time | state), method = "ML")
summary(res)
```
While alcohol consumption in the Northern Territory was higher than in Western Australia before alcohol minimum pricing, there was no significant difference in the pre-intervention trend (as indicated by the time by state interaction). Immediately after implementing minimum alcohol price, there was a significant drop in alcohol consumption in the Northern Territory but not in Western Australia (as indicated by the intervention by state interaction).
```{r}
#generating the model-based prediction
alc_mup_data$predicted <- res$fitted

#generating the interaction for ggplots
groups = interaction(alc_mup_data$intervention,alc_mup_data$state)

#ploting the time series
plot <- ggplot() +
  geom_point(data = alc_mup_data, aes(y = alcohol, x = time, color = state)) +
  geom_line(data = alc_mup_data, aes(y = predicted, x = time, color = state, group = groups)) +
  geom_vline(xintercept = max((alc_mup_data %>% filter(intervention == "0"))$time), linetype = 
               "dashed") +
  theme_bw(base_family = "sans") +
  theme(legend.position = "bottom")
plot
```
#Our model has accounted for lag-1 autocorrelation. We can evaluate if this is sufficient using the partial auto-correlation function. The acf() can be used with the type parameter set to "partial". In this analysis, we will need to plot the auto-correlation function for Western Australia and Northern Territory separately.
```{r}
#extract the residuals
alc_mup_data$residuals <- residuals(res)

#plotting the partial ACF
pacf(alc_mup_data[alc_mup_data$state == "NT",]$residuals)
pacf(alc_mup_data[alc_mup_data$state == "WA",]$residuals)
```
Autocorrelation measures how a variable is related to its past values and is a way to assess if there is a pattern or dependency within a time series.
```{r}
#Both PACF plots suggest that we should adjust for up to the lag-4 auto-correlation. The analysis can be rerun by setting the p parameter to 4, as follow.

res2 <- gls(alcohol ~ time*intervention*state,
            data = alc_mup_data,
            correlation = corARMA(p = 4, form =~ time | state), method = "ML")
summary(res2)
```

```{r}
#adjust for seasonality



#The harmonic function is used to calculate the harmonic terms calculate based on sine and cosine function
#the first parameter of this function specifies the time variable
#the second specifies the number of sine and cosine pairs to include
#the third specifies the length of the period

alc_mup_data <- cbind(alc_mup_data, data.frame(harmonic(alc_mup_data$time, 1, 12)))
alc_mup_data <- alc_mup_data %>% 
  rename(harmonic1 = X1,
         harmonic2 = X2)
res <- gls(alcohol ~ time*intervention*state + harmonic1 + harmonic2,
           data = alc_mup_data,
           correlation = corARMA(p = 1, form =~ time | state), method = "ML")
summary(res)
```

```{r}
#calculate the predicted value
alc_mup_data$predicted <- res$fitted
groups = interaction(alc_mup_data$intervention,alc_mup_data$state)

#calculate the predicted linear trend for data visualisation
alc_mup_data.linear <- alc_mup_data
alc_mup_data.linear$harmonic1 <- 0
alc_mup_data.linear$harmonic2 <- 0
alc_mup_data.linear$predicted <- predict(res, alc_mup_data.linear)

#plot the time series
plot <- ggplot() +
  geom_point(data = alc_mup_data, aes(y = alcohol, x = time, color = state)) +
  geom_line(data = alc_mup_data, aes(y = predicted, x = time, color = state, group = groups), linetype = "dashed") +
  geom_line(data = alc_mup_data.linear, aes(y = predicted, x = time, color = state, group = groups)) +
  geom_vline(xintercept = max((alc_mup_data %>% filter(intervention == "0"))$time), linetype = "dashed") +
  theme_bw(base_family = "sans") +
  theme(legend.position = "bottom")
plot
```
